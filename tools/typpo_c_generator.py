#!/usr/bin/env python

from __future__ import print_function
import os.path
import sys
try:
    import yaml
except ImportError:
    print('Please install PyYaml')
    sys.exit(1)

# TODO(rqou): Consider the possibility of dynamically generating the appropriate
# Python code to use struct to handle the described data structures (rather than
# just outputting C headers).


def typpo_filename_to_include_guard(fname):
    # Get the "base" (no path, no extension) part of the input name
    fname_base = os.path.splitext(os.path.basename(fname))[0]
    # Take the filename, make it all uppercase, and replace all non-alphanumeric
    # characters with underscores
    fname_cleaned = ''.join(
        c.upper() if c.isalnum() else '_' for c in fname_base)
    return fname_cleaned + "_TYPPO_H_"


def typpo_emit_header_start(f, input_filename):
    HEADER_START_STR = (
        "// DO NOT EDIT THIS FILE!\n"
        "// This file is autogenerated by the typpo type describer tool.\n"
        "// You should edit the source YAML file instead.\n"
        "\n"
        "#ifndef {include_guard}\n"
        "#define {include_guard}\n"
        "\n"
        "#include <stdint.h>\n"
        "\n"
        # This is kinda a hack, but the YAML code will use an alien type called
        # pointer. We add the special-casing for that here instead of in the
        # main type generation.
        "typedef void *pointer;\n"
        "\n")

    include_guard = typpo_filename_to_include_guard(input_filename)
    f.write(HEADER_START_STR.format(include_guard = include_guard))


def typpo_emit_header_end(f, input_filename):
    HEADER_START_STR = (
        "\n"
        "#endif  // {include_guard}\n"
        "\n")

    include_guard = typpo_filename_to_include_guard(input_filename)
    f.write(HEADER_START_STR.format(include_guard = include_guard))


class TyppoTypeNode(object):
    def __init__(self, _name):
        self.name = _name
        # Used for DAG linearization
        self.temp_mark = False
        self.perm_mark = False
        # Types embedded in this type
        self.embeds = []
        # Data describing the type
        self.yamlObj = None

    def __str__(self):
        return ("<Typpo Type: \"{name}\", "
            "Flags: {tf}{pf}, embeds: {embeds}, data: {data}>".format(
                name = self.name,
                tf = "T" if self.temp_mark else "",
                pf = "P" if self.perm_mark else "",
                embeds = self.embeds,
                data = self.yamlObj))

    def __repr__(self):
        return self.__str__()


class TyppoParser(object):
    # Pass in the list of types loaded from the YAML file
    def __init__(self, input_objects):
        self._input_objects = input_objects

    # First pass collects all the type names. Also marks alien types.
    def do_initial_pass(self):
        self._types = {}
        for type_desc in self._input_objects:
            name = type_desc['name']
            kind = type_desc['kind']

            new_type = TyppoTypeNode(name)
            new_type.yamlObj = type_desc
            if (kind == "alien" or kind == "base" or
                kind == "struct" or kind == "union"):
                pass
            else:
                print("WARNING: Unknown kind {}".format(kind))

            self._types[name] = new_type


    def resolve_references(self):
        for type_desc in self._input_objects:
            name = type_desc['name']
            kind = type_desc['kind']
            type_node = self._types[name]

            if kind == "alien" or kind == "base":
                pass
            elif kind == "struct" or kind == "union":
                for slot in type_desc['slots']:
                    slot_type = slot['type']

                    # print(slot)
                    is_embedded = False
                    # TODO(rqou): Move this logic at some point?
                    if slot_type.endswith('*'):
                        # pointer
                        # print("pointer!")
                        slot_type = slot_type[:-1].strip()
                    elif slot_type.endswith('[]'):
                        # flex array
                        # print("flex array!")
                        slot_type = slot_type[:-2].strip()
                        is_embedded = True
                    else:
                        is_embedded = True

                    if not slot_type in self._types:
                        # TODO(rqou): Pointer pointers (and higher) don't work
                        # properly
                        print("WARNING: Type {parent} references "
                            "unknown type {child}".format(
                                parent = name, child = slot_type))
                        # TODO(rqou): Report better errors
                        if is_embedded:
                            assert False

                    if is_embedded:
                        type_node.embeds.append(self._types[slot_type])


    def do_dag_linearization(self):
        # Uses second algorithm from
        # http://en.wikipedia.org/wiki/Topological_sorting
        sorted_types = []
        nodes_unmarked = set(self._types.values())
        def visit(n):
            print(n.name)
            if n.temp_mark:
                print("ERROR: Types have cyclic references to {name}".format(
                    name = n.name))
                assert False

            if not n.temp_mark and not n.perm_mark:
                n.temp_mark = True
                print("visiting children!")
                for m in n.embeds:
                    print("visiting child " + m.name)
                    visit(m)
                n.perm_mark = True
                # TODO(rqou): right?
                n.temp_mark = False
                nodes_unmarked.remove(n)
                sorted_types.append(n)
        while len(nodes_unmarked) > 0:
            a_node = nodes_unmarked.pop()
            # TODO(rqou): Do I need to do this?
            nodes_unmarked.add(a_node)
            visit(a_node)
        self._sorted_types = sorted_types

    SIZE_TO_C_TYPE = {
        1:          'uint8_t',
        2:          'uint16_t',
        4:          'uint32_t',
        8:          'uint64_t',
        # TODO(rqou): Is this correct?
        'native':   'uintptr_t',
    }

    def emit_typedefs_pass1(self, f):
        for type_desc in self._types.values():
            name = type_desc.yamlObj['name']
            kind = type_desc.yamlObj['kind']

            if kind == "alien":
                # Don't output these
                pass
            elif kind == "base":
                # TODO(rqou): Base doesn't properly support signed-ness
                c_type = self.SIZE_TO_C_TYPE[type_desc.yamlObj['size']]
                f.write("typedef {ctype} {newtype};\n".format(
                    ctype = c_type, newtype = name))
            elif kind == "struct":
                f.write(
                    "struct {structname};\n"
                    "typedef struct {structname} {structname};\n".format(
                        structname = name))
            elif kind == "union":
                f.write(
                    "union {unionname};\n"
                    "typedef union {unionname} {unionname};\n".format(
                        unionname = name))
            else:
                print("WARNING: Don't know how to emit for kind {} (pass1)"
                    .format(kind))

        f.write("\n")


    def emit_typedefs_pass2(self, f):
        for type_desc in self._sorted_types:
            name = type_desc.yamlObj['name']
            kind = type_desc.yamlObj['kind']

            if kind == "alien" or kind == "base":
                # These have already been emitted
                pass
            elif kind == "struct":
                f.write("struct {structname} {{\n".format(structname = name))
                for field in type_desc.yamlObj['slots']:
                    field_name = field['name'];
                    field_type = field['type'];

                    if field_type.endswith('[]'):
                        # TODO(rqou): Clean up flex array handling?
                        field_type = field_type[:-2].strip()
                        f.write("    {type} {fieldname}[];\n".format(
                            type = field_type,
                            fieldname = field_name))
                    else:
                        f.write("    {type} {fieldname};\n".format(
                            type = field_type,
                            fieldname = field_name))
                f.write("};\n")
            elif kind == "union":
                # TODO(rqou): Code duplication
                f.write("union {structname} {{\n".format(structname = name))
                for field in type_desc.yamlObj['slots']:
                    field_name = field['name'];
                    field_type = field['type'];

                    if field_type.endswith('[]'):
                        # TODO(rqou): Clean up flex array handling?
                        field_type = field_type[:-2].strip()
                        f.write("    {type} {fieldname}[];\n".format(
                            type = field_type,
                            fieldname = field_name))
                    else:
                        f.write("    {type} {fieldname};\n".format(
                            type = field_type,
                            fieldname = field_name))
                f.write("};\n")
            else:
                print("WARNING: Don't know how to emit for kind {} (pass2)"
                    .format(kind))


def main():
    if len(sys.argv) < 3:
        print("Usage: %s input.yaml output.h" % sys.argv[0])
        sys.exit(1)

    input_filename = sys.argv[1]
    output_filename = sys.argv[2]

    inf = open(input_filename, 'r')
    inputYaml = inf.read()
    inf.close()
    inputObjects = yaml.load(inputYaml)

    typpo_parser = TyppoParser(inputObjects)
    typpo_parser.do_initial_pass()
    for k,x in typpo_parser._types.iteritems():
        print(str(x))
    print("########################################")
    typpo_parser.resolve_references()
    for k,x in typpo_parser._types.iteritems():
        print(str(x))
    print("########################################")
    typpo_parser.do_dag_linearization()
    for k,x in typpo_parser._types.iteritems():
        print(str(x))
    print("//////////////")
    for x in typpo_parser._sorted_types:
        print(x.name)
    print("########################################")

    with open(output_filename, 'w') as outf:
        typpo_emit_header_start(outf, input_filename)
        typpo_parser.emit_typedefs_pass1(outf)
        typpo_parser.emit_typedefs_pass2(outf)
        typpo_emit_header_end(outf, input_filename)


if __name__ == '__main__':
    main()
